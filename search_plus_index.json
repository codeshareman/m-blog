{"./":{"url":"./","title":"写在前面的话","keywords":"","body":"理解、实现、提升 do someting, well done; "},"books/code-war/minipack.html":{"url":"books/code-war/minipack.html","title":"撸一个 webpack","keywords":"","body":"🤔 撸一个 webpack webpack 是一个现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图会映射项目所需的每个模块，并生成一个或多个 bundle。 一、几个基础概念: chunk: bundle 是由许多个 chunk 组成的，通常 chunkh 和 bundle 一一对应，但也有一对多的关系 entry chunk 包含 webpack runtime code 并且是最先执行的 chunk initial chunk 包含同步加载进来的 module 且不包含 runtime code 的 chunk 在 entry chunk 执行后再执行的 normal chunk 使用 require.ensure、import()异步加载进来的 module，会被放到 normal chunk 中 bundle: 由多个不同的模块产生，它是已经加载完毕和被编译后的源代码的最终版本 graph: 用来描述文件之间的依赖关系的图。从入口起点开始以递归的方式构建各个文件之间的依赖关系 loader: 资源正确加载的加载器 plugins: 增强型功能插件 与 loader 互补 二、什么是模块 模块 是一组与特定功能相关的代码。它封装了实现细节，公开了一个公共 API，并与其他模块结合以构建更大的应用程序。 模块化 就是为了实现更高级别的抽象，它将一类或多种实现封装到一个模块中，我们不必考虑模块内是怎样的依赖关系，仅仅调用它暴露出来的 API 即可 例如: 其中 person.js 中依赖 man.js ，在引用时如果你把它们的引用顺序颠倒就会报错。在大型项目中，这种依赖关系就显得尤其重要，而且极难维护.除此之外，它还有以下问题： 一切都加载到全局上下文中，导致名称冲突和覆盖 涉及开发人员的大量手动工作，以找出依赖关系和包含顺序 所以，模块化非常重要 ！！！ 由于前后端 JavaScript 分别搁置在 HTTP 的两端，它们扮演的角色不同，侧重点也不一样。 浏览器端的 JavaScript 需要经历从一个服务器端分发到多个客户端执行，而服务器端 JS 则是相同的代码需要多次执行。前者的瓶颈在于宽带，后者的瓶颈则在于 CPU 等内存资源。前者需要通过网络加载代码，后者则需要从磁盘中加载， 两者的加载速度也不是在一个数量级上的。 所以前后端的模块定义不是一致的，其中服务器端的模块定义为: CJS（CommonJS）：旨在用于服务器端 JavaScript 的同步定义，Node 的模块系统实际上基于 CJS； ? 但是 CJS 是同步方式，那么问题来了： 服务端：文件都在本地，即使卡住主线程依然不会受到太大的影响， 浏览器端： 如果 UI 线程被阻塞，需要等待大量的网络请求和脚本执行完成，那么将带来极大的开销，并且大大降低用户体验 SO，前端的浏览器模块定义来了: AMD（异步模块定义）：被定义为用于浏览器中模块的异步模型，RequireJS 是 AMD 最受欢迎的实现； UMD（通用模块定义）：它本质上一段 JavaScript 代码，放置在库的顶部，可让任何加载程序、任何环境加载它们； ES2015（ES6）：定义了异步导入和导出模块的语义，会编译成 require/exports 来执行的，这也是我们现今最常用的模块定义； 三、什么是打包器 打包器 就是把 javascript 模块化代码转化为浏览器可识别运行的优化工具 常用打包工具 webpack、rollup、gulp、grunt 举个例子，你在一个 html 文件中引入多个 JavaScript 文件： Graph 关系 模块化 在 HTML 引入时，我们需要注意这 4 个文件的引入顺序（如果顺序出错，项目就会报错），如果将其扩展到具有实际功能的可用的 web 项目中，那么可能需要引入几十个文件，依赖关系更是复杂。 所以，我们需要将每个依赖项模块化，让打包器帮助我们管理这些依赖项，让每个依赖项能够在正确的时间、正确的地点被正确的引用 捆绑 另外，当浏览器打开该网页时，每个 js 文件都需要一个单独的 http 请求，即 4 个往返请求，才能正确的启动你的项目。 我们知道浏览器加载模块很慢，即使是 HTTP/2 支持有效的加载许多小文件，但其性能都不如加载一个更加有效（即使不做任何优化）。 所以 我们可以将文件最终合并为一个，但是又可以让这哥文件可以和通过某种依赖关系，动态加载资源 如此以来，便只有一次网络请求啦 四、如何打包 解析入口文件，并获取相关的依赖 递归遍历所有文件之间的依赖关系，生成依赖图 使用依赖关系图，生成一个浏览器可以执行的函数(IIFE) IIFE 立即执行函数，由于 JavaScript 变量的作用域仅限于函数内部，所以你不必考虑它会污染全局变量。 通过文件流将生成的文件字符串输出到 output 指定的文件中 fs.writeFile 写入 dist/bundle.js 即可。 五、写在最后 其实 webpack 最核心的部分就在于 graph 依赖图，将依赖的资源的 code 包装在一个 IIFE 里便生成了 bundle.js 文件。 具体代码实现就不贴下来了，给大家一些思考的空间，下面介绍几个会用到的 babel 包并奉上 graph 依赖结构图 babel 包 const babelParser = require('@babel/parser'); const { transformFromAst } = require('@babel/core'); const traverse = require('@babel/traverse').default; // 将模块内容转换为抽象语法树AST const ast = babelParser.parse(content, { sourceType: 'module', }); // 将抽象语法树转换为code const { code } = transformFromAst(ast, null, { presets: ['@babel/preset-env'], }); // 根据抽象语法树获取对应的文件依赖 traverse(ast, { // 遍历所有的 import 模块，并将相对路径放入 dependencies ImportDeclaration: ({ node }) => { dependencies.push(node.source.value); }, }); graph 依赖关系图 let graph = { []// entry 模块 \"src/entry.js\": { code: '', dependencies: [\"./src/message.js\"], mapping:{ \"./message.js\": \"src/message.js\" } }, // message 模块 \"src/message.js\": { code: '', dependencies: [], mapping:{}, } } 已经很晚了，这算是一个好的开始～ 希望自己能一直坚持，不断的提升自己～ 也希望阅读到此文章的您能有所收获～ "},"books/foundation/javascript.html":{"url":"books/foundation/javascript.html","title":"Javascript","keywords":"","body":"isNaN vs Number.isNaN isNaN('hello world'); // true Number.isNaN('hello world'); // false "},"books/practice/jest.html":{"url":"books/practice/jest.html","title":"Jest","keywords":"","body":"Jest Q: Jest 如何生成配置文件 ？ A: jest --init Q: Jest 提示找不到 \"@babel/preset-env\" 怎么解决 ？ A: Jest 在执行前会去读取 babel.config.js 或着 .babelrc 的配置，你需要去检查下是否有如下配置 // .babelrc \"test\": { \"presets\": [[\"@babel/preset-env\"], \"@babel/preset-react\", \"@babel/preset-typescript\"] } Q: Jest 中如何解析 .ts|.tsx 的测试文件？ A: // 安装 babel-jest yarn add babel-jest --dev // 在 jest.config.js 中配置 { moduleFileExtensions: ['js', 'jsx', 'ts', 'tsx'], rootDir: './', transform: { // '^.+\\\\.tsx?$': 'ts-jest', '^.+\\\\.[t|j]sx?$': 'babel-jest', }, testMatch: [ '/__test__/*.(test|specs).[jt]s?(x)', // \"**/__tests__/**/*.[jt]s?(x)\" // \"**/?(*.)+(spec|test).[tj]s?(x)\" ], } Q: enzyme 如何对 react 项目进行单元测试 A: // step 1 yarn add enzyme @types/enzyme --dev yarn add enzyme-adapter-react-16 --dev // step 2 创建一个配置文件 setupFiles -> enzyme.config.js import Enzyme from 'enzyme' import Adapter from 'enzyme-adapter-react-16' Enzyme.configure({ adapter: new Adapter() }) // step 3 在jest.config.js中配置 setupFiles: ['./enzyme.config.js'], // step 4 在package.json中指定jest配置文件 { \"test\": \"jest --config ./jest.config.js\" } "},"books/practice/taro.html":{"url":"books/practice/taro.html","title":"Taro","keywords":"","body":"Taro Q: comand ‘taro’ not found ? A: 需要添加软链接 ln -f -s ~/.config/yarn/global/node_modules/@tarojs/cli/bin/taro /usr/local/bin/taro "},"books/configuration/jest.html":{"url":"books/configuration/jest.html","title":"Jest 配置","keywords":"","body":"Jest.config.js module.exports = { // 这个选项告诉Jest，应该自动模拟测试中所有导入的模块，测试中使用的所有模块都将具有替代实现，从而保持API外观。 // automock: false, // 在 n 次失败后停止测试 // bail: 0, // 解决模块时，请尊重package.json中的“浏览器”字段 // browser: false, // jest依赖信息缓存目录 // cacheDirectory: \"/private/var/folders/59/x8j7sht14wv9q3k5zvt0w4fm0000gn/T/jest_dx\", // 在每次测试之间自动清除模拟调用和实例 // clearMocks: false, // 在测试时候是否收集覆盖率信息 collectCoverage: true, // 指定收集覆盖率的信息源 // collectCoverageFrom:[ \"**/*.{js,jsx}\", \"!**/node_modules/**\", \"!**/vendor/**\" ], // 覆盖率文件输出目录 coverageDirectory: '__test__/coverage', // 覆盖率信息忽略配置 // coveragePathIgnorePatterns: [ // \"/node_modules/\" // ], // Jest在编写覆盖率报告时使用的报告人姓名列表 // coverageReporters: [ // \"json\", // \"text\", // \"lcov\", // \"clover\" // ], // 为覆盖结果配置最低阈值实施的对象 // coverageThreshold: null, // 定制依赖项提取器的路径 // dependencyExtractor: null, // 使调用过时的API抛出有用的错误消息 // errorOnDeprecated: false, // 使用Glob模式数组从忽略的文件强制覆盖 // forceCoverageMatch: [], // 导出异步功能的模块的路径，该异步功能在所有测试套件之前触发一次 // globalSetup: null, // 导出异步功能的模块的路径，该异步功能在所有测试套件之后触发一次 // globalTeardown: null, // 一组全局变量，需要在所有测试环境中使用 // globals: {}, // 用于运行测试的最大工作量。 可以指定为％或数字。 例如。 maxWorkers：10％将使用您的CPU数量的10％+ 1作为最大工/// 人数。 maxWorkers：2个最多使用2个工人。 // maxWorkers: \"50%\", // 从需求模块的位置向上递归搜索的目录名称数组 // moduleDirectories: [ // \"node_modules\" // ], // 模块使用的文件扩展名数组 moduleFileExtensions: ['js', 'json', 'jsx', 'ts', 'tsx', 'node'], // 从正则表达式到模块名称的映射，允许使用单个模块存根资源 moduleNameMapper: { '^@src(.*)$': '/src$1', // '.(css|scss|less)$': '/__test__/mock/styleMock.js', }, // 一个正则表达式模式字符串数组，在被模块加载器视为“可见”之前，已与所有模块路径匹配 // modulePathIgnorePatterns: [], // 激活测试结果通知 // notify: false, // 指定通知模式的枚举。 需要 {notify：true} // notifyMode: \"failure-change\", // 用作Jest配置基础的预设 // preset: null, // 从一个或多个项目运行测试 // projects: null, // 使用此配置选项将自定义报告程序添加到Jest // reporters: undefined, // 每次测试之间自动重置模拟状态 // resetMocks: false, // 在运行每个单独的测试之前，请重置模块注册表 // resetModules: false, // 自定义解析器的路径 // resolver: null, // 在每次测试之间自动恢复模拟状态 // restoreMocks: false, // Jest应该在其中扫描测试和模块的根目录 rootDir: './', // Jest用于在其中搜索文件的目录的路径列表 // roots: [ // \"\" // ], // 允许您使用自定义运行器，而不是Jest的默认测试运行器 // runner: \"jest-runner\", // 在每次测试之前运行一些代码以配置或设置测试环境的模块的路径 // setupFiles: [], setupFiles: ['./setupTests.js'], // 在每次测试之前运行一些代码以配置或设置测试框架的模块的路径列表 // setupFilesAfterEnv: [], // Jest用于快照测试的快照序列化程序模块的路径列表 // snapshotSerializers: [], // 用于测试的测试环境 // testEnvironment: \"jest-environment-jsdom\", // 将传递给testEnvironment的选项 // testEnvironmentOptions: {}, // 添加位置字段以测试结果 // testLocationInResults: false, // 测试匹配 testMatch: ['/__test__/**/*.(spec|test).[jt]s?(x)'], // Jest忽略检测的测试文件的regexp模式或模式数组 // testPathIgnorePatterns: [ // \"/node_modules/\" // ], // Jest用于检测测试文件的regexp模式或模式数组 // testRegex: [], // 自定义结果运行器 // testResultsProcessor: null, // 自定义测试运行器 // testRunner: \"jasmine2\", // This option sets the URL for the jsdom environment. It is reflected in properties such as location.href // testURL: \"http://localhost\", testURL: 'https://test.com?empty=&num=0&str=str&cstr=中文&encode=%e4%b8%ad%e6%96%87', // 将此值设置为“fake”可将虚假计时器用于“setTimeout”等功能 // timers: \"real\", // 从正则表达式到转换器路径的映射 transform: { '^.+\\\\.[t|j]sx?$': 'babel-jest', '^.+\\\\.(css|scss|less)$': '/__test__/mock/cssTransform.js', '\\\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$': '/__test__/mock/fileTransform.js', }, // 与所有源文件路径匹配的regexp模式字符串数组，匹配的文件将跳过转换 // transformIgnorePatterns: [ // \"/node_modules/\" // ], // 不需要mock的模块正则匹配 // unmockedModulePathPatterns: undefined, // 指示是否应在运行期间报告每个测试 // verbose: null, // 在监视模式下重新运行测试之前，与所有源文件路径匹配的一组regexp模式 // watchPathIgnorePatterns: [], // 是否使用watchman // watchman: true, } "},"books/interview/sourcecode/React.html":{"url":"books/interview/sourcecode/React.html","title":"React","keywords":"","body":"React 源码 - 学习笔记 "},"books/interview/algorithm-principle/":{"url":"books/interview/algorithm-principle/","title":"アルゴリズムの原理","keywords":"","body":"算法原理 React Diff React Fiber "},"books/interview/javascript.html":{"url":"books/interview/javascript.html","title":"Javascript","keywords":"","body":"Javascript "},"books/interview/css.html":{"url":"books/interview/css.html","title":"CSS","keywords":"","body":"CSS "},"books/interview/architecture.html":{"url":"books/interview/architecture.html","title":"Architecture","keywords":"","body":"前端架构 "},"books/life/delicious.html":{"url":"books/life/delicious.html","title":"美味しいお店","keywords":"","body":"美味しいお店 大邑县 庹血旺 地址: 大邑县营经大道200号 "},"books/life/journey.html":{"url":"books/life/journey.html","title":"南東、北西","keywords":"","body":"南東、北西 大邑县 天府花溪谷 地址: 成都市大邑县金星乡和平村 "}}